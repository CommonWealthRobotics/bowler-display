# Kernel Display Design

## Functional Requirements

### Startup Sequence

The display starts by loading a gRPC server. The display must be given a kernel address and port number. It may receive this information through a cmdline argument. If this argument is not given, then the display must wait for this information to be set using the [Configuration Options](#configuration-operations) in the gRPC server. This display may also present the user with a selection of kernels to connect to.

Once the display has this information, it asks the connected kernel for its robot config file and uses its internal kernel to load the robot config file and run CAD generation. The output CSGs are displayed in a 3D view.

### gRPC Server

#### Configuration Operations

- Connect to a kernel (by IP address and TCP port)

#### Robot Viz Operations

The CSGs of the robot are generated by a kernel inside the display when a robot config file is loaded. This robot config file can be specified via the [Configuration Operations](#configuration-operations) or via a cmdline argument.

- Set a state vector containing all the joint angles of the robot
  - The display knows how to do FK using these joint angles because it has the robot config file and a kernel.

#### 3D View Operations

We need these operations to support developing a CAD script. For example, a user developing a vitamin CAD generator wants to iterate by changing script and seeing the CAD result in a 3D view. These gRPC calls will not be used to visualize the robot; the calls under [Robot Viz Operations](#robot-viz-operations) are used for that.

- Set the 3D data using a list of CSGs.
- Update the frame transform of a CSG.

#### Data Logging Operations

- Add a data source using its ID, name, and type.
  - Once added, the user can see the data source in the data logging window.
- Remove a data source using its ID.
- Add data to a data source using its ID and a list of data points.
  - Use a list of data points here instead of forcing a single data point because data may come in to the kernel faster than we can send it to the display if we send each point separately. Sending a list of data points allows the kernel to buffer data more effectively.

### 3D View

- The 3D view must display the current state of the robot.
- The 3D view must support displaying CSGs returned from scripts.

### Data Logging

- The user may select data sources to display from a list of available data sources.
  - The user must select how to display a data source (e.g., line chart, 3D view, video feed).
  - Multiple data sources of compatible types (e.g., two number series) may be added to the same display (e.g., two number series on the same line chart).
- Data source displays are organized in a grid. The user may drag-and-drop individual displays to organize them.
- Data that has been logged must be able to be saved and exported to other formats (e.g., CSV) if the data type supports it (e.g., when exporting to a CSV you can export numerical data but not images or frame transforms).
- The number of data points to buffer per-data-source-type must be configurable via the settings.
  - E.g. 10k numerical data points
  - E.g. 1k frame transforms
  - E.g. 100 images

#### Plotting Methods

- Most of the plots types can be handled using [ChartFX](https://github.com/GSI-CS-CO/chart-fx).
- Use a 3D view to display a labeled cube to visualize frame transforms.

### Settings

- The user must be able to open a modal settings window to configure various kernel display settings.

## Non-Functional Requirements

### Open Source

- All core components and their dependencies must be open-source under a compatible license. Some optional, non-core components may have closed-source dependencies.

### Portability

- x86_64 Windows, macOS, and Linux must be supported.
